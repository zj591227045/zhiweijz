#!/bin/bash

# È¢ÑÁÆóÁªìËΩ¨‰∏ìÁî®‰øÆÂ§çËÑöÊú¨
# ‰∏ìÈó®ÈíàÂØπÈ¢ÑÁÆóÁªìËΩ¨ÈóÆÈ¢òÁöÑËØäÊñ≠Âíå‰øÆÂ§çÂ∑•ÂÖ∑

set -e

echo "=== È¢ÑÁÆóÁªìËΩ¨‰∏ìÁî®‰øÆÂ§çÂ∑•ÂÖ∑ ==="
echo "ÂΩìÂâçÊó∂Èó¥: $(date)"

# Ê£ÄÊü•ÊòØÂê¶Âú®Ê≠£Á°ÆÁöÑÁõÆÂΩï
if [ ! -f "docker-compose.yml" ]; then
    echo "‚ùå ÈîôËØØ: ËØ∑Âú®ÂåÖÂê´ docker-compose.yml ÁöÑÁõÆÂΩï‰∏ãËøêË°åÊ≠§ËÑöÊú¨"
    exit 1
fi

# Ê£ÄÊü•Docker ComposeÔºàÊîØÊåÅÊñ∞ÊóßÁâàÊú¨Ôºâ
DOCKER_COMPOSE_CMD=""
if docker compose version &> /dev/null; then
    DOCKER_COMPOSE_CMD="docker compose"
elif command -v docker-compose &> /dev/null; then
    DOCKER_COMPOSE_CMD="docker-compose"
else
    echo "‚ùå ÈîôËØØ: Êú™ÊâæÂà∞ docker compose Êàñ docker-compose ÂëΩ‰ª§"
    exit 1
fi

# Ê£ÄÊü•ÂÆπÂô®Áä∂ÊÄÅ
echo "üîç Ê£ÄÊü•ÂÆπÂô®Áä∂ÊÄÅ..."
BACKEND_STATUS=$($DOCKER_COMPOSE_CMD ps -q backend 2>/dev/null)
if [ -z "$BACKEND_STATUS" ]; then
    BACKEND_STATUS=$($DOCKER_COMPOSE_CMD -p zhiweijz ps -q backend 2>/dev/null)
    if [ -z "$BACKEND_STATUS" ]; then
        echo "‚ùå ÈîôËØØ: ÂêéÁ´ØÂÆπÂô®Êú™ËøêË°å"
        exit 1
    else
        DOCKER_COMPOSE_CMD="$DOCKER_COMPOSE_CMD -p zhiweijz"
    fi
fi

BACKEND_RUNNING=$(docker inspect --format='{{.State.Running}}' zhiweijz-backend 2>/dev/null)
if [ "$BACKEND_RUNNING" != "true" ]; then
    echo "‚ùå ÈîôËØØ: ÂêéÁ´ØÂÆπÂô®Êú™Ê≠£Â∏∏ËøêË°å"
    exit 1
fi

echo "‚úÖ ÂÆπÂô®Áä∂ÊÄÅÊ≠£Â∏∏"

# ËØ¢ÈóÆÊâßË°åÊ®°Âºè
echo ""
echo "ÈÄâÊã©ÊâßË°åÊ®°Âºè:"
echo "1. ËØäÊñ≠Ê®°Âºè (ÂàÜÊûêÈ¢ÑÁÆóÁªìËΩ¨ÈóÆÈ¢ò)"
echo "2. ‰øÆÂ§çÊ®°Âºè (‰øÆÂ§çÁªìËΩ¨ÈáëÈ¢ùÂíåÂéÜÂè≤ËÆ∞ÂΩï)"
echo "3. ÈáçÊñ∞ËÆ°ÁÆóÊ®°Âºè (ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÁªìËΩ¨)"
echo "4. ÈÄÄÂá∫"

read -p "ËØ∑ËæìÂÖ•ÈÄâÈ°π (1-4): " mode

case $mode in
    1)
        MODE="diagnose"
        echo "üîç ËØäÊñ≠Ê®°Âºè: ÂàÜÊûêÈ¢ÑÁÆóÁªìËΩ¨ÈóÆÈ¢ò"
        ;;
    2)
        MODE="fix"
        echo "üîß ‰øÆÂ§çÊ®°Âºè: ‰øÆÂ§çÁªìËΩ¨ÈáëÈ¢ùÂíåÂéÜÂè≤ËÆ∞ÂΩï"
        ;;
    3)
        MODE="recalculate"
        echo "üîÑ ÈáçÊñ∞ËÆ°ÁÆóÊ®°Âºè: ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÁªìËΩ¨"
        echo ""
        echo "‚ö†Ô∏è  Ë≠¶Âëä: ËøôÂ∞ÜÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÈ¢ÑÁÆóÁöÑÁªìËΩ¨ÈáëÈ¢ù!"
        read -p "Á°ÆËÆ§ÊâßË°å? (y/N): " confirm
        if [[ ! $confirm =~ ^[Yy]$ ]]; then
            echo "Â∑≤ÂèñÊ∂àÊìç‰Ωú"
            exit 0
        fi
        ;;
    4)
        echo "ÈÄÄÂá∫"
        exit 0
        ;;
    *)
        echo "‚ùå Êó†ÊïàÈÄâÈ°π"
        exit 1
        ;;
esac

# ÂàõÂª∫È¢ÑÁÆóÁªìËΩ¨‰øÆÂ§çËÑöÊú¨
TEMP_SCRIPT="/tmp/budget-rollover-fix-temp.js"

cat > "$TEMP_SCRIPT" << EOF
/**
 * È¢ÑÁÆóÁªìËΩ¨‰∏ìÁî®‰øÆÂ§çËÑöÊú¨
 */

const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

class BudgetRolloverFixService {
  constructor() {
    this.currentDate = new Date();
    this.currentYear = this.currentDate.getFullYear();
    this.currentMonth = this.currentDate.getMonth() + 1;
    this.lastMonth = this.currentMonth === 1 ? 12 : this.currentMonth - 1;
    this.lastMonthYear = this.currentMonth === 1 ? this.currentYear - 1 : this.currentYear;
    this.mode = process.argv[2] || 'diagnose';
  }

  async run() {
    console.log('='.repeat(80));
    console.log('È¢ÑÁÆóÁªìËΩ¨‰∏ìÁî®‰øÆÂ§çÂ∑•ÂÖ∑');
    console.log(\`ÊâßË°åÊó∂Èó¥: \${new Date().toLocaleString()}\`);
    console.log(\`ÂΩìÂâçÊúà‰ªΩ: \${this.currentYear}-\${this.currentMonth}\`);
    console.log(\`‰∏ä‰∏™Êúà‰ªΩ: \${this.lastMonthYear}-\${this.lastMonth}\`);
    console.log(\`ÊâßË°åÊ®°Âºè: \${this.mode}\`);
    console.log('='.repeat(80));

    try {
      switch (this.mode) {
        case 'diagnose':
          await this.diagnoseRolloverIssues();
          break;
        case 'fix':
          await this.fixRolloverIssues();
          break;
        case 'recalculate':
          await this.recalculateAllRollovers();
          break;
        default:
          console.error('Êú™Áü•ÁöÑÊâßË°åÊ®°Âºè:', this.mode);
      }
    } catch (error) {
      console.error('ÊâßË°åÂ§±Ë¥•:', error);
    } finally {
      await prisma.\$disconnect();
    }
  }

  async diagnoseRolloverIssues() {
    console.log('\\nüîç 1. ËØäÊñ≠È¢ÑÁÆóÁªìËΩ¨ÈóÆÈ¢ò');
    console.log('-'.repeat(50));

    // Ëé∑Âèñ‰∏ä‰∏™ÊúàÂêØÁî®ÁªìËΩ¨ÁöÑÈ¢ÑÁÆó
    const lastMonthStart = new Date(this.lastMonthYear, this.lastMonth - 1, 1);
    const lastMonthEnd = new Date(this.lastMonthYear, this.lastMonth, 0);

    const rolloverBudgets = await prisma.budget.findMany({
      where: {
        startDate: { gte: lastMonthStart },
        endDate: { lte: lastMonthEnd },
        rollover: true,
        budgetType: 'PERSONAL'
      },
      include: {
        user: { select: { id: true, name: true } },
        familyMember: { select: { id: true, name: true, isCustodial: true } },
        accountBook: { select: { id: true, name: true, type: true } }
      }
    });

    console.log(\`ÊâæÂà∞ \${rolloverBudgets.length} ‰∏™ÂêØÁî®ÁªìËΩ¨ÁöÑ‰∏äÊúàÈ¢ÑÁÆó\`);

    let issueCount = 0;
    const issues = [];

    for (const budget of rolloverBudgets) {
      console.log(\`\\nüìä ÂàÜÊûêÈ¢ÑÁÆó: \${budget.name} (\${budget.id})\`);
      console.log(\`  Ë¥¶Êú¨: \${budget.accountBook?.name}\`);
      console.log(\`  Áî®Êà∑: \${budget.user?.name || 'ÊâòÁÆ°Áî®Êà∑'}\`);
      console.log(\`  ‰∏äÊúàÈáëÈ¢ù: \${budget.amount}\`);
      console.log(\`  ‰∏äÊúàÁªìËΩ¨ÈáëÈ¢ù: \${budget.rolloverAmount || 0}\`);

      // ËÆ°ÁÆóÂÆûÈôÖÊîØÂá∫
      const spent = await this.calculateBudgetSpent(budget);
      const totalAvailable = Number(budget.amount) + Number(budget.rolloverAmount || 0);
      const shouldRollover = totalAvailable - spent;

      console.log(\`  ÂÆûÈôÖÊîØÂá∫: \${spent}\`);
      console.log(\`  Â∫îÁªìËΩ¨ÈáëÈ¢ù: \${shouldRollover}\`);

      // Êü•ÊâæÂØπÂ∫îÁöÑÂΩìÊúàÈ¢ÑÁÆó
      const currentBudget = await this.findCurrentMonthBudget(budget);

      if (currentBudget) {
        console.log(\`  ‚úÖ ÊâæÂà∞ÂΩìÊúàÈ¢ÑÁÆó: \${currentBudget.id}\`);
        console.log(\`  ÂΩìÊúàÂü∫Á°ÄÈáëÈ¢ù: \${currentBudget.amount}\`);
        console.log(\`  ÂΩìÊúàÁªìËΩ¨ÈáëÈ¢ù: \${currentBudget.rolloverAmount || 0}\`);

        const currentRollover = Number(currentBudget.rolloverAmount || 0);
        if (Math.abs(currentRollover - shouldRollover) > 0.01) {
          issueCount++;
          const issue = {
            type: 'ROLLOVER_AMOUNT_MISMATCH',
            lastBudgetId: budget.id,
            currentBudgetId: currentBudget.id,
            expected: shouldRollover,
            actual: currentRollover,
            difference: shouldRollover - currentRollover
          };
          issues.push(issue);
          console.log(\`  ‚ùå ÁªìËΩ¨ÈáëÈ¢ù‰∏çÂåπÈÖç! ÊúüÊúõ: \${shouldRollover}, ÂÆûÈôÖ: \${currentRollover}, Â∑ÆÂºÇ: \${issue.difference}\`);
        } else {
          console.log(\`  ‚úÖ ÁªìËΩ¨ÈáëÈ¢ùÊ≠£Á°Æ\`);
        }
      } else {
        issueCount++;
        const issue = {
          type: 'MISSING_CURRENT_BUDGET',
          lastBudgetId: budget.id,
          shouldRollover: shouldRollover
        };
        issues.push(issue);
        console.log(\`  ‚ùå Êú™ÊâæÂà∞ÂØπÂ∫îÁöÑÂΩìÊúàÈ¢ÑÁÆó\`);
      }
    }

    console.log(\`\\nüìã ËØäÊñ≠ÊÄªÁªì:\`);
    console.log(\`  Ê£ÄÊü•ÁöÑÈ¢ÑÁÆóÊï∞Èáè: \${rolloverBudgets.length}\`);
    console.log(\`  ÂèëÁé∞ÁöÑÈóÆÈ¢òÊï∞Èáè: \${issueCount}\`);

    if (issues.length > 0) {
      console.log(\`\\nüö® ÂèëÁé∞ÁöÑÈóÆÈ¢ò:\`);
      issues.forEach((issue, index) => {
        console.log(\`  \${index + 1}. \${issue.type}\`);
        if (issue.type === 'ROLLOVER_AMOUNT_MISMATCH') {
          console.log(\`     È¢ÑÁÆóID: \${issue.currentBudgetId}\`);
          console.log(\`     Â∑ÆÂºÇ: \${issue.difference}\`);
        } else if (issue.type === 'MISSING_CURRENT_BUDGET') {
          console.log(\`     ‰∏äÊúàÈ¢ÑÁÆóID: \${issue.lastBudgetId}\`);
          console.log(\`     Â∫îÁªìËΩ¨ÈáëÈ¢ù: \${issue.shouldRollover}\`);
        }
      });

      console.log(\`\\nüí° Âª∫ËÆÆÊìç‰Ωú:\`);
      console.log(\`  1. ËøêË°å‰øÆÂ§çÊ®°Âºè: bash scripts/budget-rollover-fix.sh (ÈÄâÊã©‰øÆÂ§çÊ®°Âºè)\`);
      console.log(\`  2. ËøêË°åÈáçÊñ∞ËÆ°ÁÆóÊ®°Âºè: bash scripts/budget-rollover-fix.sh (ÈÄâÊã©ÈáçÊñ∞ËÆ°ÁÆóÊ®°Âºè)\`);
    } else {
      console.log(\`\\nüéâ ÊâÄÊúâÈ¢ÑÁÆóÁªìËΩ¨ÈÉΩÊ≠£Á°Æ!\`);
    }
  }

  async calculateBudgetSpent(budget) {
    const transactions = await prisma.transaction.findMany({
      where: {
        accountBookId: budget.accountBookId,
        type: 'EXPENSE',
        date: {
          gte: budget.startDate,
          lte: budget.endDate
        },
        ...(budget.categoryId && { categoryId: budget.categoryId }),
        ...(budget.familyMemberId ? 
          { familyMemberId: budget.familyMemberId } : 
          { userId: budget.userId }
        )
      }
    });

    return transactions.reduce((sum, t) => sum + Number(t.amount), 0);
  }

  async findCurrentMonthBudget(lastBudget) {
    const currentMonthStart = new Date(this.currentYear, this.currentMonth - 1, 1);
    const currentMonthEnd = new Date(this.currentYear, this.currentMonth, 0);

    const query = {
      startDate: { gte: currentMonthStart },
      endDate: { lte: currentMonthEnd },
      budgetType: 'PERSONAL',
      accountBookId: lastBudget.accountBookId
    };

    if (lastBudget.familyMemberId) {
      query.familyMemberId = lastBudget.familyMemberId;
    } else {
      query.userId = lastBudget.userId;
      query.familyMemberId = null;
    }

    return await prisma.budget.findFirst({ where: query });
  }

  async fixRolloverIssues() {
    console.log('\\nüîß 2. ‰øÆÂ§çÈ¢ÑÁÆóÁªìËΩ¨ÈóÆÈ¢ò');
    console.log('-'.repeat(50));

    const lastMonthStart = new Date(this.lastMonthYear, this.lastMonth - 1, 1);
    const lastMonthEnd = new Date(this.lastMonthYear, this.lastMonth, 0);

    const rolloverBudgets = await prisma.budget.findMany({
      where: {
        startDate: { gte: lastMonthStart },
        endDate: { lte: lastMonthEnd },
        rollover: true,
        budgetType: 'PERSONAL'
      }
    });

    let fixedCount = 0;
    let errorCount = 0;

    for (const budget of rolloverBudgets) {
      try {
        const spent = await this.calculateBudgetSpent(budget);
        const totalAvailable = Number(budget.amount) + Number(budget.rolloverAmount || 0);
        const shouldRollover = totalAvailable - spent;

        const currentBudget = await this.findCurrentMonthBudget(budget);

        if (currentBudget) {
          const currentRollover = Number(currentBudget.rolloverAmount || 0);

          if (Math.abs(currentRollover - shouldRollover) > 0.01) {
            await prisma.budget.update({
              where: { id: currentBudget.id },
              data: { rolloverAmount: shouldRollover }
            });

            // ËÆ∞ÂΩï‰øÆÂ§çÂéÜÂè≤
            await this.recordRolloverHistory(budget, currentBudget, shouldRollover, 'FIXED');

            fixedCount++;
            console.log(\`‚úÖ ‰øÆÂ§çÈ¢ÑÁÆó \${currentBudget.id}: \${currentRollover} ‚Üí \${shouldRollover}\`);
          }
        }
      } catch (error) {
        errorCount++;
        console.error(\`‚ùå ‰øÆÂ§çÈ¢ÑÁÆó \${budget.id} Â§±Ë¥•:\`, error.message);
      }
    }

    console.log(\`\\n‰øÆÂ§çÁªüËÆ°: ÊàêÂäü‰øÆÂ§ç \${fixedCount} ‰∏™È¢ÑÁÆóÔºåÂ§±Ë¥• \${errorCount} ‰∏™\`);
  }

  async recalculateAllRollovers() {
    console.log('\\nüîÑ 3. ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÈ¢ÑÁÆóÁªìËΩ¨');
    console.log('-'.repeat(50));

    // Ëé∑ÂèñÊâÄÊúâÂêØÁî®ÁªìËΩ¨ÁöÑÈ¢ÑÁÆóÔºàÊåâÊó∂Èó¥È°∫Â∫èÔºâ
    const allRolloverBudgets = await prisma.budget.findMany({
      where: {
        rollover: true,
        budgetType: 'PERSONAL'
      },
      orderBy: [
        { accountBookId: 'asc' },
        { userId: 'asc' },
        { familyMemberId: 'asc' },
        { startDate: 'asc' }
      ]
    });

    console.log(\`ÊâæÂà∞ \${allRolloverBudgets.length} ‰∏™ÂêØÁî®ÁªìËΩ¨ÁöÑÈ¢ÑÁÆó\`);

    // ÊåâÁî®Êà∑ÂíåË¥¶Êú¨ÂàÜÁªÑ
    const budgetGroups = {};
    for (const budget of allRolloverBudgets) {
      const key = \`\${budget.accountBookId}_\${budget.userId}_\${budget.familyMemberId || 'null'}\`;
      if (!budgetGroups[key]) {
        budgetGroups[key] = [];
      }
      budgetGroups[key].push(budget);
    }

    let recalculatedCount = 0;

    for (const [key, budgets] of Object.entries(budgetGroups)) {
      console.log(\`\\nÈáçÊñ∞ËÆ°ÁÆóÈ¢ÑÁÆóÁªÑ: \${key}\`);

      // ÊåâÊó∂Èó¥È°∫Â∫èÈáçÊñ∞ËÆ°ÁÆóÁªìËΩ¨Èìæ
      let previousRollover = 0;

      for (let i = 0; i < budgets.length; i++) {
        const budget = budgets[i];
        const spent = await this.calculateBudgetSpent(budget);
        const totalAvailable = Number(budget.amount) + previousRollover;
        const newRollover = totalAvailable - spent;

        // Êõ¥Êñ∞ÂΩìÂâçÈ¢ÑÁÆóÁöÑÁªìËΩ¨ÈáëÈ¢ù
        if (Math.abs(Number(budget.rolloverAmount || 0) - previousRollover) > 0.01) {
          await prisma.budget.update({
            where: { id: budget.id },
            data: { rolloverAmount: previousRollover }
          });
        }

        // ËÆ∞ÂΩïÈáçÊñ∞ËÆ°ÁÆóÂéÜÂè≤
        await this.recordRolloverHistory(budget, budget, newRollover, 'RECALCULATED');

        console.log(\`  È¢ÑÁÆó \${budget.id}: Âü∫Á°Ä=\${budget.amount}, ÁªìËΩ¨=\${previousRollover}, ÊîØÂá∫=\${spent}, Êñ∞ÁªìËΩ¨=\${newRollover}\`);

        previousRollover = newRollover;
        recalculatedCount++;
      }
    }

    console.log(\`\\nÈáçÊñ∞ËÆ°ÁÆóÁªüËÆ°: Â§ÑÁêÜ‰∫Ü \${recalculatedCount} ‰∏™È¢ÑÁÆó\`);
  }

  async recordRolloverHistory(fromBudget, toBudget, rolloverAmount, action) {
    try {
      const rolloverType = rolloverAmount >= 0 ? 'SURPLUS' : 'DEFICIT';
      const description = \`\${action}: ‰ªéÈ¢ÑÁÆó \${fromBudget.id} Âà∞È¢ÑÁÆó \${toBudget.id}, ÈáëÈ¢ù: \${rolloverAmount}\`;

      // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ìÂéÜÂè≤Ë°®
      const historyRecord = await prisma.budgetHistory.create({
        data: {
          budgetId: toBudget.id,
          period: \`\${toBudget.endDate.getFullYear()}-\${toBudget.endDate.getMonth() + 1}\`,
          amount: rolloverAmount,
          type: rolloverType,
          description: description,
          budgetAmount: toBudget.amount,
          spentAmount: null,
          previousRollover: fromBudget.rolloverAmount || 0,
          userId: toBudget.userId,
          accountBookId: toBudget.accountBookId,
          budgetType: toBudget.budgetType || 'PERSONAL'
        }
      });

      console.log(\`‚úÖ ËÆ∞ÂΩïÁªìËΩ¨ÂéÜÂè≤ÊàêÂäü: \${action} - ÂéÜÂè≤ID: \${historyRecord.id}, ÈáëÈ¢ù: \${rolloverAmount}\`);

    } catch (error) {
      console.error('ËÆ∞ÂΩïÁªìËΩ¨ÂéÜÂè≤Â§±Ë¥•:', error);
    }
  }

  async generateRolloverReport() {
    console.log('\\nüìä 4. ÁîüÊàêÈ¢ÑÁÆóÁªìËΩ¨Êä•Âëä');
    console.log('-'.repeat(50));

    const currentMonthStart = new Date(this.currentYear, this.currentMonth - 1, 1);
    const currentMonthEnd = new Date(this.currentYear, this.currentMonth, 0);

    // ÁªüËÆ°ÂΩìÂâçÊúà‰ªΩÁöÑÁªìËΩ¨ÊÉÖÂÜµ
    const rolloverHistories = await prisma.budgetHistory.findMany({
      where: {
        createdAt: {
          gte: currentMonthStart,
          lte: currentMonthEnd
        },
        type: { in: ['SURPLUS', 'DEFICIT'] }
      },
      include: {
        budget: {
          select: { name: true }
        },
        user: {
          select: { name: true }
        },
        accountBook: {
          select: { name: true }
        }
      }
    });

    const surplusCount = rolloverHistories.filter(h => h.type === 'SURPLUS').length;
    const deficitCount = rolloverHistories.filter(h => h.type === 'DEFICIT').length;
    const totalSurplus = rolloverHistories
      .filter(h => h.type === 'SURPLUS')
      .reduce((sum, h) => sum + Number(h.amount), 0);
    const totalDeficit = rolloverHistories
      .filter(h => h.type === 'DEFICIT')
      .reduce((sum, h) => sum + Math.abs(Number(h.amount)), 0);

    console.log(\`ÂΩìÂâçÊúà‰ªΩÁªìËΩ¨ÁªüËÆ°:\`);
    console.log(\`  ‰ΩôÈ¢ùÁªìËΩ¨: \${surplusCount} Á¨î, ÊÄªÈáëÈ¢ù: \${totalSurplus}\`);
    console.log(\`  ÂÄ∫Âä°ÁªìËΩ¨: \${deficitCount} Á¨î, ÊÄªÈáëÈ¢ù: \${totalDeficit}\`);
    console.log(\`  ÂáÄÁªìËΩ¨: \${totalSurplus - totalDeficit}\`);

    if (rolloverHistories.length > 0) {
      console.log(\`\\nÊúÄËøëÁöÑÁªìËΩ¨ËÆ∞ÂΩï:\`);
      rolloverHistories.slice(0, 5).forEach(history => {
        const type = history.type === 'SURPLUS' ? '‰ΩôÈ¢ù' : 'ÂÄ∫Âä°';
        console.log(\`  \${type}ÁªìËΩ¨: \${history.amount} - \${history.budget?.name} (\${history.accountBook?.name})\`);
      });
    }
  }
}

// ÊâßË°å‰øÆÂ§ç
async function main() {
  const service = new BudgetRolloverFixService();
  await service.run();
}

main().catch(console.error);
EOF

echo ""
echo "üîß ÂºÄÂßãËøêË°åÈ¢ÑÁÆóÁªìËΩ¨‰øÆÂ§ç..."

# Â∞ÜËÑöÊú¨Â§çÂà∂Âà∞ÂÆπÂô®ÁöÑÂ∑•‰ΩúÁõÆÂΩïÂπ∂ÊâßË°å
docker cp "$TEMP_SCRIPT" zhiweijz-backend:/app/budget-rollover-fix-temp.js
docker exec -w /app zhiweijz-backend node budget-rollover-fix-temp.js "$MODE"

# Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
rm -f "$TEMP_SCRIPT"
docker exec zhiweijz-backend rm -f /app/budget-rollover-fix-temp.js

echo ""
echo "‚úÖ È¢ÑÁÆóÁªìËΩ¨‰øÆÂ§çÂÆåÊàê"
