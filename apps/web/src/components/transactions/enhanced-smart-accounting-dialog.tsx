'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { apiClient } from '@/lib/api-client';
import { useDashboardStore } from '@/store/dashboard-store';
import {
  detectPlatform,
  detectMediaCapabilities,
  getOptimalRecordingConfig,
  isMediaRecordingSupported,
  isFileSelectionSupported,
  PlatformType,
  MediaCapabilities,
} from '@/utils/multimodal-platform-utils';
import {
  ensureMicrophonePermission,
  showPermissionGuide,
  checkMicrophonePermissionStatus
} from '@/utils/microphone-permissions';
import { 
  parseError,
  showError,
  showSuccess,
  showInfo,
  showWarning,
  createError,
  MultimodalErrorType,
  isRetryableError,
} from '@/utils/multimodal-error-handler';
import { SmartAccountingProgressManager } from '@/components/transactions/smart-accounting-dialog';
import { 
  MicrophoneIcon, 
  EyeIcon, 
  PhotoIcon,
  StopIcon,
  ArrowPathIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import '@/styles/smart-accounting-dialog.css';

interface EnhancedSmartAccountingDialogProps {
  isOpen: boolean;
  onClose: () => void;
  accountBookId?: string;
}

interface MultimodalAIStatus {
  speech: {
    enabled: boolean;
    provider: string;
    model: string;
    supportedFormats: string[];
    maxFileSize: number;
  };
  vision: {
    enabled: boolean;
    provider: string;
    model: string;
    supportedFormats: string[];
    maxFileSize: number;
  };
  general: {
    enabled: boolean;
    dailyLimit: number;
    userLimit: number;
  };
  smartAccounting: {
    speechEnabled: boolean;
    visionEnabled: boolean;
  };
}

export default function EnhancedSmartAccountingDialog({
  isOpen,
  onClose,
  accountBookId,
}: EnhancedSmartAccountingDialogProps) {
  const router = useRouter();
  const { refreshDashboardData } = useDashboardStore();
  
  const [description, setDescription] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingStep, setProcessingStep] = useState('');

  // Â§öÊ®°ÊÄÅÂäüËÉΩÁä∂ÊÄÅ
  const [multimodalStatus, setMultimodalStatus] = useState<MultimodalAIStatus | null>(null);
  const [platform, setPlatform] = useState<PlatformType>(PlatformType.UNKNOWN);
  const [mediaCapabilities, setMediaCapabilities] = useState<MediaCapabilities | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);
  const [audioChunks, setAudioChunks] = useState<Blob[]>([]);
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [isProcessingMultimodal, setIsProcessingMultimodal] = useState(false);
  const [recordingCancelled, setRecordingCancelled] = useState(false);
  const [touchStartPos, setTouchStartPos] = useState<{ x: number; y: number } | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const micButtonRef = useRef<HTMLButtonElement>(null);
  const [isButtonTouched, setIsButtonTouched] = useState(false);
  const [audioLevel, setAudioLevel] = useState(0);
  const audioAnalyserRef = useRef<AnalyserNode | null>(null);
  const audioDataRef = useRef<Uint8Array | null>(null);
  const animationFrameRef = useRef<number | null>(null);
  const recordingCancelledRef = useRef(false);
  const audioChunksRef = useRef<Blob[]>([]);

  // Èü≥È¢ëÂàÜÊûêÂô®ËÆæÁΩÆ
  const setupAudioAnalyser = (stream: MediaStream) => {
    try {
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaStreamSource(stream);
      
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      source.connect(analyser);
      
      audioAnalyserRef.current = analyser;
      audioDataRef.current = new Uint8Array(analyser.frequencyBinCount);
      
      // ÂºÄÂßãÂàÜÊûêÈü≥È¢ë
      analyzeAudio();
    } catch (error) {
      console.error('ËÆæÁΩÆÈü≥È¢ëÂàÜÊûêÂô®Â§±Ë¥•:', error);
    }
  };

  // ÂàÜÊûêÈü≥È¢ëÊï∞ÊçÆ
  const analyzeAudio = () => {
    if (!audioAnalyserRef.current || !audioDataRef.current) return;
    
    audioAnalyserRef.current.getByteFrequencyData(audioDataRef.current);
    
    // ËÆ°ÁÆóÈü≥È¢ëÂº∫Â∫¶
    const average = audioDataRef.current.reduce((sum, value) => sum + value, 0) / audioDataRef.current.length;
    const normalizedLevel = Math.min(100, (average / 128) * 100);
    
    setAudioLevel(normalizedLevel);
    
    if (isRecording) {
      animationFrameRef.current = requestAnimationFrame(analyzeAudio);
    }
  };

  // Ê∏ÖÁêÜÈü≥È¢ëÂàÜÊûêÂô®
  const cleanupAudioAnalyser = () => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }
    audioAnalyserRef.current = null;
    audioDataRef.current = null;
    setAudioLevel(0);
  };

  // Êñ∞Â¢ûÁä∂ÊÄÅÔºöÊªëÂä®ÊâãÂäøÊ£ÄÊµã
  const [gestureType, setGestureType] = useState<'none' | 'cancel' | 'fill-text'>('none');
  const [showGestureHint, setShowGestureHint] = useState(false);
  const gestureTypeRef = useRef<'none' | 'cancel' | 'fill-text'>('none');

  // ÂàùÂßãÂåñÂ§öÊ®°ÊÄÅÁä∂ÊÄÅ
  const loadMultimodalStatus = async () => {
    try {
      const response = await apiClient.get('/ai/multimodal/status');
      if (response?.success && response?.data) {
        setMultimodalStatus(response.data);
      }
    } catch (error) {
      console.error('Ëé∑ÂèñÂ§öÊ®°ÊÄÅAIÁä∂ÊÄÅÂ§±Ë¥•:', error);
    }
  };

  // ÂºÄÂßãÂΩïÈü≥ÔºàÈïøÊåâÂºÄÂßãÔºâ
  const startRecording = async () => {
    if (!accountBookId) {
      toast.error('ËØ∑ÂÖàÈÄâÊã©Ë¥¶Êú¨');
      return;
    }

    try {
      if (!isMediaRecordingSupported()) {
        showError(createError(
          MultimodalErrorType.PLATFORM_NOT_SUPPORTED,
          'ÂΩìÂâçËÆæÂ§á‰∏çÊîØÊåÅÂΩïÈü≥ÂäüËÉΩ'
        ));
        return;
      }

      // È¶ñÂÖàËØ∑Ê±ÇÈ∫¶ÂÖãÈ£éÊùÉÈôê
      console.log('üé§ ÂºÄÂßãËØ∑Ê±ÇÈ∫¶ÂÖãÈ£éÊùÉÈôê...');
      const permissionResult = await ensureMicrophonePermission();
      
      if (!permissionResult.granted) {
        console.error('üé§ È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù:', permissionResult.error);
        
        // Ê£ÄÊü•ÂΩìÂâçÁéØÂ¢É
        const isAndroid = typeof window !== 'undefined' && 
                         (window as any).Capacitor?.getPlatform?.() === 'android';
        
        if (permissionResult.canRetry) {
          showError(createError(
            MultimodalErrorType.PERMISSION_DENIED,
            permissionResult.error || 'È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù'
          ));
          
          // Â¶ÇÊûúÊòØAndroidÁéØÂ¢ÉÔºåÊòæÁ§∫ËØ¶ÁªÜÁöÑÊùÉÈôêÊåáÂØº
          if (isAndroid) {
            setTimeout(() => {
              showPermissionGuide(true);
            }, 2000);
          }
        } else {
          showError(createError(
            MultimodalErrorType.PLATFORM_NOT_SUPPORTED,
            permissionResult.error || 'È∫¶ÂÖãÈ£éÂäüËÉΩ‰∏çÂèØÁî®'
          ));
        }
        return;
      }

      console.log('üé§ È∫¶ÂÖãÈ£éÊùÉÈôêËé∑ÂèñÊàêÂäüÔºåÂºÄÂßãÂΩïÈü≥...');
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // ËÆæÁΩÆÈü≥È¢ëÂàÜÊûêÂô®
      setupAudioAnalyser(stream);
      
      const chunks: Blob[] = [];
      audioChunksRef.current = chunks;
      const recorder = new MediaRecorder(stream);

      // Ê∑ªÂä†Ë∂ÖÊó∂‰øùÊä§
      const recordingTimeout = setTimeout(() => {
        console.log('üé§ [StartRecording] ÂΩïÈü≥Ë∂ÖÊó∂ÔºåËá™Âä®ÂÅúÊ≠¢');
        if (recorder.state === 'recording') {
          recorder.stop();
        }
      }, 60000); // 60ÁßíË∂ÖÊó∂

      recorder.ondataavailable = (event) => {
        console.log('üé§ [MediaRecorder] Êï∞ÊçÆÂèØÁî®:', event.data.size);
        if (event.data.size > 0) {
          chunks.push(event.data);
        }
      };

      recorder.onstop = () => {
        console.log('üé§ [MediaRecorder] ÂΩïÈü≥ÂÅúÊ≠¢‰∫ã‰ª∂Ëß¶Âèë');
        clearTimeout(recordingTimeout);
        
        // Ê∏ÖÁêÜÈü≥È¢ëÂàÜÊûêÂô®
        cleanupAudioAnalyser();
        
        // ÂÅúÊ≠¢ÊâÄÊúâÈü≥È¢ëËΩ®ÈÅì
        stream.getTracks().forEach(track => {
          console.log('üé§ [MediaRecorder] ÂÅúÊ≠¢Èü≥È¢ëËΩ®ÈÅì:', track.label);
          track.stop();
        });

        // Á°Æ‰øùUIÁä∂ÊÄÅÊõ¥Êñ∞
        setIsRecording(false);
        setMediaRecorder(null);
        setIsButtonTouched(false);

        // ‰ΩøÁî® ref Êù•Ê£ÄÊü•ÂèñÊ∂àÁä∂ÊÄÅÔºåÈÅøÂÖçÈó≠ÂåÖÈóÆÈ¢ò
        const currentChunks = audioChunksRef.current;
        const currentGestureType = gestureTypeRef.current;
        console.log('üé§ [MediaRecorder] Ê£ÄÊü•Áä∂ÊÄÅ:', {
          recordingCancelled: recordingCancelledRef.current,
          chunksLength: currentChunks?.length || 0,
          gestureType: currentGestureType
        });
        
        if (!recordingCancelledRef.current && currentChunks && currentChunks.length > 0) {
          console.log('üé§ [MediaRecorder] ÂºÄÂßãËØ≠Èü≥ËØÜÂà´ÔºåÈü≥È¢ëÂùóÊï∞:', currentChunks.length, 'ÊâãÂäøÁ±ªÂûã:', currentGestureType);
          const audioBlob = new Blob(currentChunks, { type: 'audio/webm' });
          handleSpeechRecognition(audioBlob, currentGestureType);
        } else {
          console.log('üé§ [MediaRecorder] Ë∑≥ËøáËØ≠Èü≥ËØÜÂà´ÔºåÂèñÊ∂àÁä∂ÊÄÅ:', recordingCancelledRef.current, 'Èü≥È¢ëÂùóÊï∞:', currentChunks?.length || 0);
        }
        
        // Âú®Â§ÑÁêÜÂÆåÊàêÂêéÈáçÁΩÆÊâãÂäøÁä∂ÊÄÅ
        setTimeout(() => {
          gestureTypeRef.current = 'none';
        }, 100);
      };

      recorder.onerror = (event) => {
        console.error('üé§ [MediaRecorder] ÂΩïÈü≥ÈîôËØØ:', event);
        clearTimeout(recordingTimeout);
        
        // Ê∏ÖÁêÜËµÑÊ∫ê
        stream.getTracks().forEach(track => track.stop());
        setIsRecording(false);
        setMediaRecorder(null);
        
        showError(createError(
          MultimodalErrorType.RECORDING_FAILED,
          'ÂΩïÈü≥ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ'
        ));
      };

      recorder.start();
      setMediaRecorder(recorder);
      setAudioChunks(chunks);
      setIsRecording(true);
      setRecordingCancelled(false);
      recordingCancelledRef.current = false;
      
      // ÈáçÁΩÆÊâãÂäøÁä∂ÊÄÅ
      setGestureType('none');
      gestureTypeRef.current = 'none';
      setShowGestureHint(false);

      console.log('üé§ [StartRecording] ÂΩïÈü≥Â∑≤ÂêØÂä®ÔºåÁä∂ÊÄÅ:', recorder.state);
      showInfo('Ê≠£Âú®ÂΩïÈü≥ÔºåÊùæÂºÄÂÅúÊ≠¢ÔºåÂêë‰∏äÊªëÂä®ÂèñÊ∂à');
    } catch (error) {
      console.error('ÂêØÂä®ÂΩïÈü≥Â§±Ë¥•:', error);
      
      // Á°Æ‰øùÁä∂ÊÄÅÈáçÁΩÆ
      setIsRecording(false);
      setMediaRecorder(null);
      
      showError(error);
    }
  };

  // ÂÅúÊ≠¢ÂΩïÈü≥ÔºàÊùæÂºÄÊâãÊåáÔºâ
  const stopRecording = (gestureType: 'none' | 'cancel' | 'fill-text' = 'none') => {
    console.log('üé§ [StopRecording] Ë∞ÉÁî®ÂÅúÊ≠¢ÂΩïÈü≥ÔºåÂΩìÂâçÁä∂ÊÄÅ:', {
      mediaRecorder: mediaRecorder?.state,
      isRecording,
      recordingCancelled,
      gestureType
    });
    
    // Á°Æ‰øùÊâãÂäøÁ±ªÂûãÂêåÊ≠•Âà∞ ref
    gestureTypeRef.current = gestureType;
    
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      console.log('üé§ [StopRecording] Ê≠£Âú®ÂÅúÊ≠¢MediaRecorder...');
      mediaRecorder.stop();
    }
    
    // Á´ãÂç≥Êõ¥Êñ∞UIÁä∂ÊÄÅ
    setIsRecording(false);
    setMediaRecorder(null);
    setIsButtonTouched(false);
    setTouchStartPos(null);
    
    // Ê∏ÖÁêÜÈü≥È¢ëÂàÜÊûêÂô®
    cleanupAudioAnalyser();
    
    console.log('üé§ [StopRecording] ÂΩïÈü≥Áä∂ÊÄÅÂ∑≤ÈáçÁΩÆ');
  };

  // ÂèñÊ∂àÂΩïÈü≥
  const cancelRecording = () => {
    console.log('üé§ [CancelRecording] ÂèñÊ∂àÂΩïÈü≥');
    setRecordingCancelled(true);
    recordingCancelledRef.current = true;
    
    // Ê∏ÖÁ©∫Èü≥È¢ëÂùóÊï∞ÊçÆÔºåÁ°Æ‰øù‰∏ç‰ºöË¢´Â§ÑÁêÜ
    audioChunksRef.current = [];
    
    if (mediaRecorder && mediaRecorder.state === 'recording') {
      console.log('üé§ [CancelRecording] ÂÅúÊ≠¢MediaRecorder...');
      mediaRecorder.stop();
    }
    
    // Á´ãÂç≥Êõ¥Êñ∞UIÁä∂ÊÄÅ
    setIsRecording(false);
    setMediaRecorder(null);
    setIsButtonTouched(false);
    setTouchStartPos(null);
    
    // Ê∏ÖÁêÜÈü≥È¢ëÂàÜÊûêÂô®
    cleanupAudioAnalyser();
    
    showInfo('ÂΩïÈü≥Â∑≤ÂèñÊ∂à');
    
    console.log('üé§ [CancelRecording] ÂΩïÈü≥Â∑≤ÂèñÊ∂àÔºåÁä∂ÊÄÅÂ∑≤ÈáçÁΩÆ');
  };

  // Â§ÑÁêÜËß¶Êë∏ÂºÄÂßã
  const handleTouchStart = (e: React.TouchEvent) => {
    e.preventDefault();
    console.log('üé§ [TouchStart] Ëß¶Êë∏ÂºÄÂßã');
    const touch = e.touches[0];
    setTouchStartPos({ x: touch.clientX, y: touch.clientY });
    setIsButtonTouched(true);
    startRecording();
  };

  // Â§ÑÁêÜËß¶Êë∏ÁßªÂä®ÔºàÊ£ÄÊµãÊòØÂê¶Ë¶ÅÂèñÊ∂àÔºâ
  const handleTouchMove = (e: React.TouchEvent) => {
    if (!touchStartPos || !isRecording) return;

    const touch = e.touches[0];
    const deltaY = touchStartPos.y - touch.clientY;
    const deltaX = Math.abs(touch.clientX - touchStartPos.x);

    console.log('üé§ [TouchMove] Ëß¶Êë∏ÁßªÂä®:', { deltaY, deltaX });

    // Ê£ÄÊµãÊâãÂäøÁ±ªÂûã
    if (Math.abs(deltaY) > 30 && deltaX < 50) { // ÂûÇÁõ¥ÊªëÂä®ÔºåÊ∞¥Âπ≥ÂÅèÁßª‰∏çË∂ÖËøá50px
      if (deltaY > 50) {
        // Âêë‰∏äÊªëÂä® - ÂèñÊ∂àÂΩïÈü≥
        if (gestureTypeRef.current !== 'cancel') {
          setGestureType('cancel');
          gestureTypeRef.current = 'cancel';
          setShowGestureHint(true);
          console.log('üé§ [TouchMove] Ê£ÄÊµãÂà∞ÂèñÊ∂àÊâãÂäø');
        }
      } else if (deltaY < -50) {
        // Âêë‰∏ãÊªëÂä® - Â°´ÂÖ•ÊñáÊú¨Ê°Ü
        if (gestureTypeRef.current !== 'fill-text') {
          setGestureType('fill-text');
          gestureTypeRef.current = 'fill-text';
          setShowGestureHint(true);
          console.log('üé§ [TouchMove] Ê£ÄÊµãÂà∞Â°´ÂÖ•ÊñáÊú¨ÊâãÂäø');
        }
      }
    } else if (Math.abs(deltaY) < 30) {
      // Ê≤°ÊúâÊòéÊòæÁöÑÂûÇÁõ¥ÊªëÂä®
      if (gestureTypeRef.current !== 'none') {
        setGestureType('none');
        gestureTypeRef.current = 'none';
        setShowGestureHint(false);
      }
    }
  };

  // Â§ÑÁêÜËß¶Êë∏ÁªìÊùü
  const handleTouchEnd = (e: React.TouchEvent) => {
    e.preventDefault();
    console.log('üé§ [TouchEnd] Ëß¶Êë∏ÁªìÊùüÔºåÂΩìÂâçÁä∂ÊÄÅ:', { isRecording, recordingCancelled, gestureType });
    
    setIsButtonTouched(false);
    
    if (isRecording && !recordingCancelled) {
      if (gestureType === 'cancel') {
        // ‰∏äÊªëÂèñÊ∂àÂΩïÈü≥
        console.log('üé§ [TouchEnd] ÊâßË°åÂèñÊ∂àÂΩïÈü≥');
        cancelRecording();
      } else {
        // ÊùæÂºÄÂÅúÊ≠¢ÂΩïÈü≥ÔºåÊ†πÊçÆÊâãÂäøÁ±ªÂûãÂÜ≥ÂÆöÂêéÁª≠Êìç‰Ωú
        console.log('üé§ [TouchEnd] Ê≠£Â∏∏ÁªìÊùüÂΩïÈü≥ÔºåÊâãÂäøÁ±ªÂûã:', gestureType);
        stopRecording(gestureType);
      }
    } else {
      console.log('üé§ [TouchEnd] ÂΩïÈü≥Â∑≤ÂèñÊ∂àÊàñÊú™Âú®ÂΩïÈü≥Áä∂ÊÄÅ');
    }

    // ÈáçÁΩÆÊâãÂäøÁä∂ÊÄÅ
    setGestureType('none');
    // Ê≥®ÊÑèÔºö‰∏çË¶ÅÁ´ãÂç≥ÈáçÁΩÆ gestureTypeRef.currentÔºåÂõ†‰∏∫ MediaRecorder.onstop ÂèØËÉΩËøòÊ≤°ÊúâÊâßË°å
    // gestureTypeRef.current Â∞ÜÂú® MediaRecorder.onstop ‰∫ã‰ª∂Â§ÑÁêÜÂÆåÊàêÂêéÈáçÁΩÆ
    setShowGestureHint(false);
  };

  // Â§ÑÁêÜÈº†Ê†á‰∫ã‰ª∂ÔºàÊ°åÈù¢Á´ØÔºâ
  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    console.log('üé§ [MouseDown] Èº†Ê†áÊåâ‰∏ã');
    setTouchStartPos({ x: e.clientX, y: e.clientY });
    setIsButtonTouched(true);
    startRecording();
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!touchStartPos || !isRecording) return;

    const deltaY = touchStartPos.y - e.clientY;
    const deltaX = Math.abs(e.clientX - touchStartPos.x);

    console.log('üé§ [MouseMove] Èº†Ê†áÁßªÂä®:', { deltaY, deltaX });

    // Ê£ÄÊµãÊâãÂäøÁ±ªÂûãÔºà‰∏éËß¶Êë∏Áõ∏ÂêåÔºâ
    if (Math.abs(deltaY) > 30 && deltaX < 50) { // ÂûÇÁõ¥ÁßªÂä®ÔºåÊ∞¥Âπ≥ÂÅèÁßª‰∏çË∂ÖËøá50px
      if (deltaY > 50) {
        // Âêë‰∏äÁßªÂä® - ÂèñÊ∂àÂΩïÈü≥
        if (gestureTypeRef.current !== 'cancel') {
          setGestureType('cancel');
          gestureTypeRef.current = 'cancel';
          setShowGestureHint(true);
          console.log('üé§ [MouseMove] Ê£ÄÊµãÂà∞ÂèñÊ∂àÊâãÂäø');
        }
      } else if (deltaY < -50) {
        // Âêë‰∏ãÁßªÂä® - Â°´ÂÖ•ÊñáÊú¨Ê°Ü
        if (gestureTypeRef.current !== 'fill-text') {
          setGestureType('fill-text');
          gestureTypeRef.current = 'fill-text';
          setShowGestureHint(true);
          console.log('üé§ [MouseMove] Ê£ÄÊµãÂà∞Â°´ÂÖ•ÊñáÊú¨ÊâãÂäø');
        }
      }
    } else if (Math.abs(deltaY) < 30) {
      // Ê≤°ÊúâÊòéÊòæÁöÑÂûÇÁõ¥ÁßªÂä®
      if (gestureTypeRef.current !== 'none') {
        setGestureType('none');
        gestureTypeRef.current = 'none';
        setShowGestureHint(false);
      }
    }
  };

  const handleMouseUp = (e: React.MouseEvent) => {
    e.preventDefault();
    console.log('üé§ [MouseUp] Èº†Ê†áÈáäÊîæÔºåÂΩìÂâçÁä∂ÊÄÅ:', { isRecording, recordingCancelled, gestureType });
    
    setIsButtonTouched(false);
    
    if (isRecording && !recordingCancelled) {
      if (gestureType === 'cancel') {
        // ‰∏äÁßªÂèñÊ∂àÂΩïÈü≥
        console.log('üé§ [MouseUp] ÊâßË°åÂèñÊ∂àÂΩïÈü≥');
        cancelRecording();
      } else {
        // ÊùæÂºÄÂÅúÊ≠¢ÂΩïÈü≥ÔºåÊ†πÊçÆÊâãÂäøÁ±ªÂûãÂÜ≥ÂÆöÂêéÁª≠Êìç‰Ωú
        console.log('üé§ [MouseUp] Ê≠£Â∏∏ÁªìÊùüÂΩïÈü≥ÔºåÊâãÂäøÁ±ªÂûã:', gestureType);
        stopRecording(gestureType);
      }
    } else {
      console.log('üé§ [MouseUp] ÂΩïÈü≥Â∑≤ÂèñÊ∂àÊàñÊú™Âú®ÂΩïÈü≥Áä∂ÊÄÅ');
    }

    // ÈáçÁΩÆÊâãÂäøÁä∂ÊÄÅ
    setGestureType('none');
    // Ê≥®ÊÑèÔºö‰∏çË¶ÅÁ´ãÂç≥ÈáçÁΩÆ gestureTypeRef.currentÔºåÂõ†‰∏∫ MediaRecorder.onstop ÂèØËÉΩËøòÊ≤°ÊúâÊâßË°å
    // gestureTypeRef.current Â∞ÜÂú® MediaRecorder.onstop ‰∫ã‰ª∂Â§ÑÁêÜÂÆåÊàêÂêéÈáçÁΩÆ
    setShowGestureHint(false);
  };

  // Â§ÑÁêÜËØ≠Èü≥ËØÜÂà´
  const handleSpeechRecognition = async (audioBlob: Blob, gestureType: 'none' | 'cancel' | 'fill-text') => {
    console.log('üé§ [SpeechRecognition] ÂºÄÂßãÂ§ÑÁêÜËØ≠Èü≥ËØÜÂà´ÔºåÊâãÂäøÁ±ªÂûã:', gestureType);
    
    if (!accountBookId) {
      toast.error('ËØ∑ÂÖàÈÄâÊã©Ë¥¶Êú¨');
      return;
    }

    setIsProcessingMultimodal(true);

    try {
      const formData = new FormData();
      formData.append('audio', audioBlob, 'recording.webm');
      formData.append('accountBookId', accountBookId);

      const response = await apiClient.post('/ai/smart-accounting/speech', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
        timeout: 60000,
      });

      if (response && response.data && response.data.text) {
        const recognizedText = response.data.text;
        
        // Ê†πÊçÆÊâãÂäøÁ±ªÂûãÊâßË°å‰∏çÂêåÊìç‰Ωú
        if (gestureType === 'cancel') {
          // ÂèñÊ∂àÂΩïÈü≥ÁöÑÊÉÖÂÜµ‰∏ãÔºå‰∏çÂ∫îËØ•Âà∞ËøôÈáåÔºåËøôÈáåÂè™ÊòØ‰øùÊä§ÊÄß‰ª£Á†Å
          console.log('üé§ [SpeechRecognition] ÂΩïÈü≥Â∑≤ÂèñÊ∂àÔºåË∑≥ËøáÂ§ÑÁêÜ');
          return;
        } else if (gestureType === 'fill-text') {
          // ‰∏ãÊªëÊâãÂäøÔºö‰ªÖÂ°´ÂÖ•ÊñáÊú¨Ê°ÜÔºå‰∏çËá™Âä®Ë∞ÉÁî®ËÆ∞Ë¥¶
          console.log('üé§ [SpeechRecognition] ‰∏ãÊªëÊâãÂäøÔºö‰ªÖÂ°´ÂÖ•ÊñáÊú¨Ê°Ü');
          setDescription(recognizedText);
          showSuccess('ËØ≠Èü≥Â∑≤ËΩ¨Êç¢‰∏∫ÊñáÂ≠ó');
          // Ê≥®ÊÑèÔºöËøôÈáå‰∏çË∞ÉÁî®‰ªª‰ΩïËÆ∞Ë¥¶ÈÄªËæë
        } else {
          // Ê≠£Â∏∏ÊùæÂºÄÊâãÂäøÔºöÁõ¥Êé•Ë∞ÉÁî®ËÆ∞Ë¥¶
          console.log('üé§ [SpeechRecognition] Ê≠£Â∏∏ÊùæÂºÄÊâãÂäøÔºöÁõ¥Êé•ËÆ∞Ë¥¶');
          
          // ÁîüÊàêÂîØ‰∏ÄËøõÂ∫¶ID
          const progressId = `voice-direct-add-${Date.now()}`;
          
          // Ëé∑ÂèñÊô∫ËÉΩËÆ∞Ë¥¶ËøõÂ∫¶ÁÆ°ÁêÜÂô®ÂÆû‰æã
          const progressManager = SmartAccountingProgressManager.getInstance();
          
          // ÊòæÁ§∫ËøõÂ∫¶ÈÄöÁü•Âπ∂Á´ãÂç≥ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
          progressManager.showProgress(progressId, 'Ê≠£Âú®ÂêØÂä®Êô∫ËÉΩËÆ∞Ë¥¶...');
          onClose(); // Á´ãÂç≥ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
          
          // ËÆæÁΩÆËØÜÂà´ÁöÑÊñáÊú¨Âà∞ÊèèËø∞Ê°ÜÔºà‰∏∫‰∫Ü‰øùÊåÅ‰∏ÄËá¥ÊÄßÔºâ
          setDescription(recognizedText);
          
          // Ë∞ÉÁî®Áõ¥Êé•Ê∑ªÂä†ËÆ∞Ë¥¶API
          try {
            const response = await apiClient.post(
              `/ai/account/${accountBookId}/smart-accounting/direct`,
              { description: recognizedText },
              { timeout: 60000 }
            );

            if (response && response.id) {
              progressManager.showProgress(progressId, 'ËÆ∞Ë¥¶ÊàêÂäü', 'success');

              // Âà∑Êñ∞‰ª™Ë°®ÁõòÊï∞ÊçÆ
              if (accountBookId) {
                try {
                  await refreshDashboardData(accountBookId);
                } catch (refreshError) {
                  console.error('Âà∑Êñ∞‰ª™Ë°®ÁõòÊï∞ÊçÆÂ§±Ë¥•:', refreshError);
                }
              }

              // Ê∏ÖÁ©∫ÊèèËø∞
              setDescription('');
            } else {
              progressManager.showProgress(progressId, 'ËÆ∞Ë¥¶Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â°´ÂÜô', 'error');
            }
          } catch (error: any) {
            console.error('ËØ≠Èü≥Áõ¥Êé•ËÆ∞Ë¥¶Â§±Ë¥•:', error);
            
            let errorMessage = 'ËÆ∞Ë¥¶Â§±Ë¥•ÔºåËØ∑ÈáçËØï';
            
            if (error.response) {
              const errorData = error.response.data;
              if (error.response.status === 429 && errorData?.type === 'TOKEN_LIMIT_EXCEEDED') {
                errorMessage = `${errorData.error || 'Token‰ΩøÁî®ÈáèÂ∑≤ËææÈôêÈ¢ùÔºåËØ∑Á®çÂêéÂÜçËØï'}`;
              } else if (errorData?.info && errorData.info.includes('ËÆ∞Ë¥¶Êó†ÂÖ≥')) {
                errorMessage = 'ÊÇ®ÁöÑÊèèËø∞‰ºº‰πé‰∏éËÆ∞Ë¥¶Êó†ÂÖ≥ÔºåËØ∑Â∞ùËØïÊèèËø∞ÂÖ∑‰ΩìÁöÑÊ∂àË¥πÊàñÊî∂ÂÖ•ÊÉÖÂÜµ';
              } else {
                errorMessage = `ËÆ∞Ë¥¶Â§±Ë¥•: ${errorData?.error || errorData?.message || 'ÊúçÂä°Âô®ÈîôËØØ'}`;
              }
            } else if (error.request) {
              errorMessage = 'ÁΩëÁªúËøûÊé•ÂºÇÂ∏∏ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÂêéÈáçËØï';
            }
            
            progressManager.showProgress(progressId, errorMessage, 'error');
          }
        }
      } else {
        showError(createError(
          MultimodalErrorType.RECOGNITION_FAILED,
          'ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•ÔºåËØ∑ÈáçËØï'
        ));
      }
    } catch (error: any) {
      console.error('ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•:', error);
      showError(error);
    } finally {
      setIsProcessingMultimodal(false);
    }
  };

  // Â§ÑÁêÜÂõæÁâáËÆ∞Ë¥¶
  const handleImageRecording = () => {
    if (!accountBookId) {
      toast.error('ËØ∑ÂÖàÈÄâÊã©Ë¥¶Êú¨');
      return;
    }

    if (!isFileSelectionSupported()) {
      showError(createError(
        MultimodalErrorType.PLATFORM_NOT_SUPPORTED,
        'ÂΩìÂâçËÆæÂ§á‰∏çÊîØÊåÅÊñá‰ª∂ÈÄâÊã©ÂäüËÉΩ'
      ));
      return;
    }

    fileInputRef.current?.click();
  };

  // Â§ÑÁêÜÂõæÁâáÈÄâÊã©
  const handleImageSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // È™åËØÅÊñá‰ª∂Ê†ºÂºè
    if (!file.type.startsWith('image/')) {
      showError(createError(
        MultimodalErrorType.INVALID_FILE_FORMAT,
        'ËØ∑ÈÄâÊã©ÂõæÁâáÊñá‰ª∂'
      ));
      return;
    }

    handleImageRecognition(file);
  };

  // Â§ÑÁêÜÂõæÁâáËØÜÂà´
  const handleImageRecognition = async (imageFile: File) => {
    if (!accountBookId) {
      toast.error('ËØ∑ÂÖàÈÄâÊã©Ë¥¶Êú¨');
      return;
    }

    setIsProcessingMultimodal(true);

    try {
      const formData = new FormData();
      formData.append('image', imageFile);
      formData.append('accountBookId', accountBookId);

      const response = await apiClient.post('/ai/smart-accounting/vision', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
        timeout: 60000,
      });

      if (response && response.data && response.data.text) {
        const recognizedText = response.data.text;
        setDescription(recognizedText);
        showSuccess('ÂõæÁâáËØÜÂà´ÊàêÂäü');

        // Ëá™Âä®Ë∞ÉÁî®Êô∫ËÉΩËÆ∞Ë¥¶
        await handleSmartAccountingWithText(recognizedText);
      } else {
        showError(createError(
          MultimodalErrorType.RECOGNITION_FAILED,
          'ÂõæÁâáËØÜÂà´Â§±Ë¥•ÔºåËØ∑ÈáçËØï'
        ));
      }
    } catch (error: any) {
      console.error('ÂõæÁâáËØÜÂà´Â§±Ë¥•:', error);
      showError(error);
    } finally {
      setIsProcessingMultimodal(false);
      // Ê∏ÖÈô§Êñá‰ª∂ËæìÂÖ•
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  // ‰ΩøÁî®ËØÜÂà´ÁöÑÊñáÊú¨ËøõË°åÊô∫ËÉΩËÆ∞Ë¥¶
  const handleSmartAccountingWithText = async (text: string) => {
    try {
      setIsProcessing(true);
      setProcessingStep('Ê≠£Âú®ÂàÜÊûêËÆ∞Ë¥¶‰ø°ÊÅØ...');

      const response = await apiClient.post(
        `/ai/account/${accountBookId}/smart-accounting`,
        { description: text },
        { timeout: 60000 }
      );

      if (response) {
        // Â∞ÜÁªìÊûúÂ≠òÂÇ®Âà∞sessionStorageÔºå‰æõÊ∑ªÂä†‰∫§ÊòìÈ°µÈù¢‰ΩøÁî®
        sessionStorage.setItem('smartAccountingResult', JSON.stringify(response));
        showSuccess('Êô∫ËÉΩËØÜÂà´ÊàêÂäü');
        onClose();
        router.push('/transactions/new');
      } else {
        showError(createError(
          MultimodalErrorType.PROCESSING_ERROR,
          'Êô∫ËÉΩËØÜÂà´Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â°´ÂÜô'
        ));
      }
    } catch (error: any) {
      console.error('Êô∫ËÉΩËÆ∞Ë¥¶Â§±Ë¥•:', error);

      if (error.response?.data?.info && error.response.data.info.includes('ËÆ∞Ë¥¶Êó†ÂÖ≥')) {
        showInfo('ÊÇ®ÁöÑÊèèËø∞‰ºº‰πé‰∏éËÆ∞Ë¥¶Êó†ÂÖ≥ÔºåËØ∑Â∞ùËØïÊèèËø∞ÂÖ∑‰ΩìÁöÑÊ∂àË¥πÊàñÊî∂ÂÖ•ÊÉÖÂÜµ');
      } else {
        showError(error);
      }
    } finally {
      setIsProcessing(false);
      setProcessingStep('');
    }
  };

  // Êô∫ËÉΩËÆ∞Ë¥¶
  const handleSmartAccounting = async () => {
    if (!description.trim()) {
      toast.error('ËØ∑ËæìÂÖ•ÊèèËø∞');
      return;
    }

    await handleSmartAccountingWithText(description.trim());
  };

  // Â§ÑÁêÜÁõ¥Êé•Ê∑ªÂä†ËÆ∞Ë¥¶
  const handleDirectAdd = async () => {
    if (!description.trim()) {
      toast.error('ËØ∑ËæìÂÖ•ÊèèËø∞');
      return;
    }

    if (!accountBookId) {
      toast.error('ËØ∑ÂÖàÈÄâÊã©Ë¥¶Êú¨');
      return;
    }

    // ÁîüÊàêÂîØ‰∏ÄËøõÂ∫¶ID
    const progressId = `direct-add-${Date.now()}`;
    
    // Ëé∑ÂèñÊô∫ËÉΩËÆ∞Ë¥¶ËøõÂ∫¶ÁÆ°ÁêÜÂô®ÂÆû‰æã
    const progressManager = SmartAccountingProgressManager.getInstance();
    
    // ÊòæÁ§∫ËøõÂ∫¶ÈÄöÁü•Âπ∂Á´ãÂç≥ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
    progressManager.showProgress(progressId, 'Ê≠£Âú®ÂêØÂä®Êô∫ËÉΩËÆ∞Ë¥¶...');
    onClose(); // Á´ãÂç≥ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü

    try {
      // Ë∞ÉÁî®Áõ¥Êé•Ê∑ªÂä†ËÆ∞Ë¥¶API
      const response = await apiClient.post(
        `/ai/account/${accountBookId}/smart-accounting/direct`,
        { description },
        { timeout: 60000 }
      );

      if (response && response.id) {
        progressManager.showProgress(progressId, 'ËÆ∞Ë¥¶ÊàêÂäü', 'success');

        // Âà∑Êñ∞‰ª™Ë°®ÁõòÊï∞ÊçÆ
        if (accountBookId) {
          try {
            await refreshDashboardData(accountBookId);
          } catch (refreshError) {
            console.error('Âà∑Êñ∞‰ª™Ë°®ÁõòÊï∞ÊçÆÂ§±Ë¥•:', refreshError);
          }
        }

        setDescription('');
      } else {
        progressManager.showProgress(progressId, 'ËÆ∞Ë¥¶Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â°´ÂÜô', 'error');
      }
    } catch (error: any) {
      console.error('Áõ¥Êé•Ê∑ªÂä†ËÆ∞Ë¥¶Â§±Ë¥•:', error);

      let errorMessage = 'ËÆ∞Ë¥¶Â§±Ë¥•ÔºåËØ∑ÈáçËØï';

      if (error.response) {
        const errorData = error.response.data;

        if (error.response.status === 429 && errorData?.type === 'TOKEN_LIMIT_EXCEEDED') {
          errorMessage = `${errorData.error || 'Token‰ΩøÁî®ÈáèÂ∑≤ËææÈôêÈ¢ùÔºåËØ∑Á®çÂêéÂÜçËØï'}`;
        } else if (errorData?.info && errorData.info.includes('ËÆ∞Ë¥¶Êó†ÂÖ≥')) {
          errorMessage = 'ÊÇ®ÁöÑÊèèËø∞‰ºº‰πé‰∏éËÆ∞Ë¥¶Êó†ÂÖ≥ÔºåËØ∑Â∞ùËØïÊèèËø∞ÂÖ∑‰ΩìÁöÑÊ∂àË¥πÊàñÊî∂ÂÖ•ÊÉÖÂÜµ';
        } else {
          errorMessage = `ËÆ∞Ë¥¶Â§±Ë¥•: ${errorData?.error || errorData?.message || 'ÊúçÂä°Âô®ÈîôËØØ'}`;
        }
      } else if (error.request) {
        errorMessage = 'ÁΩëÁªúËøûÊé•ÂºÇÂ∏∏ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÂêéÈáçËØï';
      }

      progressManager.showProgress(progressId, errorMessage, 'error');
    }
  };

  // ÊâãÂä®ËÆ∞Ë¥¶
  const handleManualAccounting = () => {
    onClose();
    router.push('/transactions/new');
  };

  // Ê∏ÖÈô§ÂõæÁâáÈÄâÊã©
  const clearImageSelection = () => {
    setSelectedImage(null);
    setImagePreview(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  useEffect(() => {
    if (isOpen) {
      // ÂàùÂßãÂåñÂ§öÊ®°ÊÄÅÁä∂ÊÄÅ
      loadMultimodalStatus();
    }
    
    // ÁªÑ‰ª∂Âç∏ËΩΩÊó∂Ê∏ÖÁêÜËµÑÊ∫ê
    return () => {
      if (isRecording) {
        cleanupAudioAnalyser();
      }
    };
  }, [isOpen, isRecording]);

  if (!isOpen) return null;

  // Â§ÑÁêÜÁÇπÂáªÁ©∫ÁôΩÂ§ÑÂÖ≥Èó≠ÂºπÁ™ó
  const handleOverlayClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div className="smart-accounting-dialog-overlay" onClick={handleOverlayClick}>
      <div className="smart-accounting-dialog" style={{ position: 'relative' }}>
        <div className="smart-accounting-dialog-header">
          <h3 className="smart-accounting-dialog-title">Êô∫ËÉΩËÆ∞Ë¥¶</h3>
          <button className="smart-accounting-dialog-close" onClick={onClose}>
            <XMarkIcon className="w-5 h-5" />
          </button>
        </div>

        {isProcessing ? (
          <div className="smart-accounting-processing">
            <div className="smart-accounting-loading">
              <div className="spinner"></div>
            </div>
            <p className="smart-accounting-processing-text">{processingStep || 'Ê≠£Âú®Â§ÑÁêÜ...'}</p>
          </div>
        ) : (
          <>
            <div className="smart-accounting-dialog-content">
              <p className="smart-accounting-dialog-subtitle">ËæìÂÖ•‰∏ÄÂè•ËØùÔºåËá™Âä®ËØÜÂà´ËÆ∞Ë¥¶‰ø°ÊÅØ</p>

              {/* ÊñáÊú¨ËæìÂÖ• */}
              <div className="smart-accounting-input-wrapper">
                <textarea
                  className="smart-accounting-textarea"
                  placeholder="‰æãÂ¶ÇÔºöÊò®Â§©Âú®Ê≤ÉÂ∞îÁéõ‰π∞‰∫ÜÊó•Áî®ÂìÅÔºåËä±‰∫Ü128.5ÂÖÉ"
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  rows={3}
                  autoFocus
                />
              </div>

              {/* ÂΩïÈü≥Áä∂ÊÄÅÊèêÁ§∫ */}
              {isRecording && (
                <div className="recording-indicator">
                  <div className="icon-container">
                    <i className="fas fa-microphone"></i>
                  </div>
                  <p className="title">
                    Ê≠£Âú®ÂΩïÈü≥...
                  </p>
                  {showGestureHint && (
                    <p className="hint gesture-hint">
                      {gestureType === 'cancel' ? 'ÊùæÂºÄÂèñÊ∂àÂΩïÈü≥' : 
                       gestureType === 'fill-text' ? 'ÊùæÂºÄÂ°´ÂÖ•ÊñáÊú¨Ê°Ü' : 
                       'ÊùæÂºÄËΩ¨Êç¢ÊñáÂ≠óÂπ∂ËÆ∞Ë¥¶'}
                    </p>
                  )}
                  {!showGestureHint && (
                    <p className="default-hint">
                      ‰∏äÊªëÂèñÊ∂à ‚Ä¢ ‰∏ãÊªëÂ°´ÂÖ•ÊñáÊú¨Ê°Ü ‚Ä¢ ÊùæÂºÄÁõ¥Êé•ËÆ∞Ë¥¶
                    </p>
                  )}
                </div>
              )}

              <div className="smart-accounting-buttons">
                <button
                  className="smart-accounting-button identify-button"
                  onClick={handleSmartAccounting}
                  disabled={isProcessing || !description.trim()}
                >
                  Êô∫ËÉΩËØÜÂà´
                </button>

                <button
                  className="smart-accounting-button direct-button"
                  onClick={handleDirectAdd}
                  disabled={!description.trim()}
                >
                  Áõ¥Êé•Ê∑ªÂä†
                </button>
              </div>

              <div className="smart-accounting-manual-wrapper">
                {/* ÈöêËóèÁöÑÊñá‰ª∂ËæìÂÖ• */}
                <input
                  ref={fileInputRef}
                  type="file"
                  accept="image/*"
                  onChange={handleImageSelect}
                  style={{ display: 'none' }}
                />

                {/* Â∫ïÈÉ®ÊåâÈíÆÁªÑÔºöÁõ∏Êú∫ - ÊâãÂä®ËÆ∞Ë¥¶ - È∫¶ÂÖãÈ£é */}
                <div style={{
                  display: 'flex',
                  gap: '12px',
                  alignItems: 'center'
                }}>
                  {/* Áõ∏Êú∫ÊåâÈíÆ */}
                  <button
                    type="button"
                    onClick={handleImageRecording}
                    disabled={isProcessing || isProcessingMultimodal}
                    style={{
                      width: '48px',
                      height: '48px',
                      borderRadius: '12px',
                      border: 'none',
                      backgroundColor: 'var(--success-color, #22c55e)',
                      color: 'white',
                      fontSize: '18px',
                      cursor: (isProcessing || isProcessingMultimodal) ? 'not-allowed' : 'pointer',
                      opacity: (isProcessing || isProcessingMultimodal) ? 0.6 : 1,
                      transition: 'all 0.2s ease',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)'
                    }}
                    title="ÂõæÁâáËÆ∞Ë¥¶"
                  >
                    {isProcessingMultimodal ? (
                      <i className="fas fa-spinner fa-spin"></i>
                    ) : (
                      <i className="fas fa-camera"></i>
                    )}
                  </button>

                  {/* ÊâãÂä®ËÆ∞Ë¥¶ÊåâÈíÆ */}
                  <button
                    className="smart-accounting-manual-button"
                    onClick={handleManualAccounting}
                    style={{ flex: 1 }}
                  >
                    ÊâãÂä®ËÆ∞Ë¥¶
                  </button>

                  {/* È∫¶ÂÖãÈ£éÊåâÈíÆ */}
                  <button
                    ref={micButtonRef}
                    type="button"
                    disabled={isProcessing || isProcessingMultimodal}
                    onTouchStart={handleTouchStart}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp} // Èº†Ê†áÁ¶ªÂºÄÊåâÈíÆÂå∫ÂüüÊó∂‰πüÂÅúÊ≠¢ÂΩïÈü≥
                    className={`mic-button ${isRecording ? 'recording' : ''} ${isButtonTouched ? 'touched' : ''}`}
                    style={{
                      width: '48px',
                      height: '48px',
                      borderRadius: '12px',
                      border: 'none',
                      backgroundColor: isRecording ? 'var(--error-color, #ef4444)' : 'var(--warning-color, #f59e0b)',
                      color: 'white',
                      fontSize: '18px',
                      cursor: (isProcessing || isProcessingMultimodal) ? 'not-allowed' : 'pointer',
                      opacity: (isProcessing || isProcessingMultimodal) ? 0.6 : 1,
                      transition: 'all 0.2s ease',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: isRecording ? '0 4px 16px rgba(239, 68, 68, 0.4)' : '0 2px 8px rgba(0, 0, 0, 0.1)',
                      transform: isRecording ? 'scale(1.1)' : (isButtonTouched ? 'scale(1.05)' : 'scale(1)'),
                      userSelect: 'none',
                      WebkitUserSelect: 'none',
                      WebkitTouchCallout: 'none',
                      position: 'relative',
                      overflow: 'hidden'
                    }}
                    title={isRecording ? 'ÊùæÂºÄÂÅúÊ≠¢ÂΩïÈü≥ÔºåÂêë‰∏äÊªëÂä®ÂèñÊ∂à' : 'ÈïøÊåâÂºÄÂßãËØ≠Èü≥ËÆ∞Ë¥¶'}
                  >
                    {/* ËÉåÊôØÂëºÂê∏ÊïàÊûú */}
                    {isRecording && (
                      <div
                        className="breathing-effect"
                        style={{
                          position: 'absolute',
                          top: '50%',
                          left: '50%',
                          transform: 'translate(-50%, -50%)',
                          width: '100%',
                          height: '100%',
                          borderRadius: '12px',
                          background: 'radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 50%, transparent 70%)',
                          animation: 'breathe 2s ease-in-out infinite'
                        }}
                      />
                    )}
                    
                    {/* Èü≥È¢ëÂèØËßÜÂåñ */}
                    {isRecording && (
                      <div
                        className="audio-visualizer"
                        style={{
                          position: 'absolute',
                          bottom: '2px',
                          left: '50%',
                          transform: 'translateX(-50%)',
                          width: '80%',
                          height: '4px',
                          backgroundColor: 'rgba(255,255,255,0.3)',
                          borderRadius: '2px',
                          overflow: 'hidden'
                        }}
                      >
                        <div
                          style={{
                            width: `${Math.max(5, audioLevel)}%`,
                            height: '100%',
                            backgroundColor: 'white',
                            borderRadius: '2px',
                            transition: 'width 0.1s ease'
                          }}
                        />
                      </div>
                    )}
                    
                    {/* ÂõæÊ†á */}
                    <div style={{ position: 'relative', zIndex: 1 }}>
                      {isProcessingMultimodal ? (
                        <i className="fas fa-spinner fa-spin"></i>
                      ) : isRecording ? (
                        <i className="fas fa-stop"></i>
                      ) : (
                        <i className="fas fa-microphone"></i>
                      )}
                    </div>
                  </button>
                </div>
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
